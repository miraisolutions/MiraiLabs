#* @apiTitle API adspool
#* @apiDescription Application serving a pool of advertisments for web sites.

# Unless otherwise specified, to run the examples:
#   1- Click Run API
#   2- Test interactively with swagger

#Set Variable with path to tmp folder in current RProj
Sys.setenv(TMP_PATH = file.path(rprojroot::find_rstudio_root_file(), "tmp"))

# The package adspool contains data and utils for the examples.
library("adspool")


# > GET ----

#* Return ads data in json format.
#* @tag Rendering output.
#* @param onlyMatching Return only ads with matching criteria or otherwise complete the request with non matching ads.
#* @param n The number of elements to get.
#* @param ad_subcat The subgategories of the ads to get.
#* @param ad_cat The categories of the ads to get.
#* @param ad_name The names of the ads to get.
#* @serializer unboxedJSON
#* @get /ads_data
get_ads_data <- function(ad_name = NULL, ad_cat = NULL, ad_subcat = NULL, n = 25, onlyMatching = FALSE) {
    select_ads(ad_name = ad_name,
               ad_cat = ad_cat,
               ad_subcat = ad_subcat,
               n = as.integer(n),
               onlyMatching = as.logical(onlyMatching))
}

#* Return all the ads of a given client id. Dynamic route.
#* @tag Rendering output.
#* @param ad_client The id of the client of the ads to get.
#* @get /client/<ad_client:int>
get_clients_ads <- function(ad_client = NULL) {
    subset_ads(ad_client = ad_client)
}

# Image serializers @png and @jpeg cause the graphical output of an endpoint to be written to
# a file and then returned to the client using jpeg() or png(). The annotation accepts parameters in this case.

#* Return a graph generated by the app in @jpeg format.
#* @tag Rendering output.
#* @serializer contentType list(type = "image/jpeg")
#* @get /ads/profit/graph
#* @jpeg (width = 700, height = 400)
get_ads_profit_graph <- function() {
    bp <- read.ads() %>%
        group_by(category, subcategory) %>%
        summarize(gross_revenue = sum(click_count * click_rate)) %>%
        ggplot2::ggplot(ggplot2::aes(x=category, y = gross_revenue, fill = subcategory)) +
        ggplot2::coord_flip()
    print(bp + ggplot2::geom_bar(stat="identity"))
}


# Plumber comes with serializers for: json (default), html, jpeg, png, htmlwidget, unboxedJSON

# Any other serialization method must be handled in the R code, and can be specified with
# @serializer contentType defines the header Content-Type, but does no serialization.

#* Return an image for and ad from a file. Rendering output as binary.
#* @tag Rendering output.
#* @serializer contentType list(type = "image/jpeg")
#* @param ad_id The advertisement id.
#* @get /ads/img/<ad_id:int>
get_ads_img <- function(ad_id) {
    select_ads(ad_id = ad_id)[["img_path"]] %>%
        file.path("img", .) %>%
        system.file(package = "adspool") %>%
        readBin("raw", n=file.info(.)$size)
}

#* Get invoice pdf for a given client id.
#* @tag Rendering output.
#* @param id id of client
#* @serializer contentType list(type="application/pdf")
#* @get /openinvoices/client/<id:int>
get_openinvoices <- function(id, res){
    invoice.pdf <- system.file("rmd/invoice.pdf", package = "adspool")
    invoice_detail <- read.ads() %>%
        select(-id) %>%
        filter(client_id == id) %>%
        mutate(amount = click_count * click_rate)
    invoice_summary <- invoice_detail %>%
        summarise(Subtotal = sum(amount)) %>%
        mutate(Tax = Subtotal * 0.08,
               Total = Subtotal + Tax)
    suppressMessages(
        rmarkdown::render(
            input = system.file("rmd/invoice.Rmd", package = "adspool"),
            output_file = "invoice.pdf",
            output_format = "pdf_document",
            params = list(client_id = id,
                          invoice_detail = invoice_detail,
                          invoice_summary = invoice_summary)
        )    
    )
    
    # This line tells the client to handle the content as an attachment
    res$setHeader("Content-Disposition", "attachment; filename=invoice.pdf")
    
    readBin(invoice.pdf, "raw", n = file.info(invoice.pdf)$size)
}

# > R obj script
#* Get all the ads in a .rds file.
#* @tag Rendering output.
#* @serializer contentType list(type="application/octet-stream")
#* @get /ads/Robj
get_ads_robj <- function(res) {
    saveRDS(read.ads(), file = "ads.rds")
    res$setHeader("Content-Disposition", "attachment; filename=ads.rds")
    # Read in the raw contents of the binary filw
    bin <- readBin("ads.rds", "raw", n = file.info("ads.rds")$size)
}

# > DELETE ----

#* Delete one advertisement. Unauthenticated!
#* @tag Updating application data.
#* @param ad_id The id of the ad to delete.
#* @serializer unboxedJSON
#* @delete /ads/<ad_id:int>
delete_ad <- function(ad_id) {
    remove_ads(ad_id = ad_id)
}

# > POST ----

#* Create a new advertisement. Unauthenticated!
#* @tag Updating application data.
#* @param ad_click_rate rate per click
#* @param ad_client id of the client owner of the ad
#* @param ad_subcat The subgategories of the ads to get.
#* @param ad_cat The categories of the ads to get.
#* @param ad_name The names of the ads to get.
#* @post /ads
post_create_ad <- function(ad_name, ad_cat = NULL, ad_subcat = NULL, ad_client, ad_click_rate, res) {
    # Error control inside the endpoint handler
    if (as.numeric(ad_click_rate) < 0){
        res$status <- 400 # bad request
        res$body <- list(error = "ad_click_rate must be a positive number")
        return(res$body)
    }
    add_ad(newad = ad_name,
           newad_cat = ad_cat,
           newad_subcat = ad_subcat,
           newad_client = ad_client,
           newad_click_rate = ad_click_rate)
}

# > POST Request body ----

#* POST Create a new advertisement with a postBody. Unauthenticated!
#* @tag Reading complex input.
#* @post /ads_postbody
post_create_ad_postbody <- function(req) {
    body <- jsonlite::fromJSON(req$postBody)
    add_ad(newad = body$ad_name,
           newad_cat = body$ad_cat,
           newad_subcat = body$ad_subcat,
           newad_client = body$ad_client,
           newad_click_rate = body$ad_click_rate
           )
}

# To test post_create_ad_postbody:
# Run job "run_03_advanced.R"
if (FALSE) {
    resp <- httr::POST(
        url = "http://127.0.0.1:8000/",                             # base url
        path  = "ads_postbody",                                     # complete path with endpoint
        body = list(ad_name = "Test1",                              # body
                    ad_cat = "Game",
                    ad_subcat = "Videogame",
                    ad_client = 1,
                    ad_click_rate = 0.1),
        encode = "json")
    httr::content(resp) %>% as.data.frame
}

# > PUT ----

#* Update an advertisement. Unauthenticated!
#* @tag Updating application data.
#* @param ad_id value to update (mandatory).
#* @put /ad/<ad_id:int>
put_modify_ad <- function(ad_id, req) {
    body <- jsonlite::fromJSON(req$postBody)
    update_ad(ad_id = ad_id,
              ad_name = body$ad_name,
              ad_cat = body$ad_cat,
              ad_subcat = body$ad_subcat,
              ad_client = body$ad_client,
              ad_click_rate = body$ad_click_rate)
}
# To test put_modify_ad:
# Run job "run_03_advanced.R"
if (FALSE) {
    resp <- httr::PUT(
        url = "http://127.0.0.1:8000/",                             # base url
        path  = paste0("ad/", 10),                                  # passing ad_id in the url
        body = list(ad_name = "Test1",                              # body
                    ad_cat = "Game",
                    ad_subcat = "Videogame",
                    ad_client = 1,
                    ad_click_rate = 0.1),
        query = list(ad_client = 5, ad_click_rate = 0.05))          # parameters to put_modify_ad, in the query
    httr::content(resp) %>% as.data.frame
}

# > Cookies ----
#* Capture users behavior on a cookie (and app data).
#* @tag Cookies.
#* @param ad_id the id of the advertisement for which to mimic a click
#* @post /mimic/click/<ad_id:int>
post_mimic_click <- function(ad_id, res){
    res$setCookie("last click on ad_id:", ad_id)
    update_ad(ad_id = ad_id,
              ad_click_count = subset_ads(ad_id = ad_id)["click_count"] + 1)
}
# To test post_mimic_click:
# Run job "run_03_advanced.R"
if (FALSE) {
    resp <- httr::POST(
        url = "http://127.0.0.1:8000/",                            # base url
        path  = paste0("/mimic/click/", 1))                        # passing ad_id in the url
    as.data.frame(httr::content(resp))
    httr::cookies(resp)
}

#* Send Session info with Cookies
#* @tag Cookies.
#* @get /counter
get_counter <- function(req, res) {
    count <- 0
    if (!is.null(req$cookies$visitcounter)) {
        count <- as.numeric(req$cookies$visitcounter)
    }
    res$setCookie("visitcounter", count + 1, expiration = 60 ) # expiration is in seconds
    return(paste0("This is visit #", count))
}
# To test get_counter:
# Run job "run_03_advanced.R"
if (FALSE) {
    resp <- httr::GET(
        url = "http://127.0.0.1:8000/",                            # base url
        path  = paste0("/counter"),                                # passing ad_id in the url
        httr::set_cookies(visitcounter = "1"))                     # set cookie
    as.data.frame(httr::content(resp))
    httr::cookies(resp)
}

#* Send Session info with Cookies
#* @tag Cookies.
#* @param ad_subcat value for cookies - is a list of sub-categories
#* @serializer unboxedJSON
#* @post /mimic/usersession
post_mimic_usersession <- function(req, res, ad_subcat){
    if (missing(ad_subcat)) {
        stop("You must specify a value for the ad_subcat of the user session.")
    }
    ad_subcat_history <- ad_subcat
    
    if (!is.null(req$cookies$adsubcathistory)){
        ad_subcat_history %<>% c(unlist(strsplit(req$cookies$adsubcathistory, ",")))
    }
    res$setCookie(name = "adsubcathistory", value = paste0(ad_subcat_history, collapse = ", "), path="/")
    return(ad_subcat_history)
}
# To test post_mimic_usersession:
# Run job "run_03_advanced.R"
if (FALSE) {
    resp <- httr::POST(
        url = "http://127.0.0.1:8000/",                             # base url
        path  = paste0("/mimic/usersession"),                       # passing endpoint in the url
        query = list(ad_subcat = "Videogame"))                      # parameters to put_mimic_usersession, in the query
    as.data.frame(httr::content(resp))
    httr::cookies(resp)
}

#* Get ads based on a current user session info stored in a cookie
#* @tag Cookies.
#* @param n_ads number of ads to return
#* @get /ads/with.cookie
get_ads_with.cookie <- function(req, n_ads = 5){
    ad_subcat_filter <- if (!is.null(req$cookies$adsubcathistory)){
        unlist(strsplit(req$cookies$adsubcathistory, ", "))
    } else {
        NULL
    }
    print(paste("selecting adds based on the history of subcategories:", req$cookies$adsubcathistory))
    select_ads(n = as.integer(n_ads),
               ad_subcat = paste(ad_subcat_filter, collapse = "|"))
}
# To test get_ads_with.cookie:
# Run job "run_03_advanced.R"
if (FALSE) {
    resp <- httr::GET(
         url = "http://127.0.0.1:8000/",                             # base url
         path  = "ads/with.cookie",
         query = list(n_ads = 10),
         httr::set_cookies(ad_subcat_history = "Sport,Videogames"))
    httr::content(resp) %>% dplyr::bind_rows()
}

# > Filters ----

# >> FILTER logger
#* Log some information about the incoming request
#* @filter logger
filter_logger <- function(req){
    line <- sprintf("%s %s - %s %s%s - %s@%s",
                    Sys.time(), req$HTTP_HOST, req$REQUEST_METHOD, req$PATH_INFO, req$QUERY_STRING,
                    req$HTTP_USER_AGENT, req$REMOTE_ADDR)
    print(line)
    write.logs(line)
    plumber::forward()
}

# >> FILTER errorhandling
#* Throw error if input is not valid for create_ad (post /ad)
#* Throw error if input is not valid for get_ads_img (get /ads/img/<ad_id:int>)
#* @filter errorhandler
filter_errorhandler <- function(req, res){
    if (req$REQUEST_METHOD == "POST" && grepl("^/ad$", req$PATH_INFO)) {
        req_params <- c("ad_name", "ad_client", "ad_click_rate") %>% 
            sapply(function(x) grepl(x, req$QUERY_STRING))
        if (!all(req_params)) {
            res$status <- 400 # Bad request
            msg <- paste0(sprintf("%s cannot be empty", names(which(!req_params))), collapse = ", ")
            res$body <- list(error = msg)
            return(res$body)
        }
    }
    if (req$REQUEST_METHOD == "GET" && grepl("^/ads/img/", req$PATH_INFO)) {
        ad_id <- as.integer(sub("/ads/img/", "", req$PATH_INFO))
        if (!is.element(ad_id, subset_ads()$id)){
            # The status code should be an an error code (410, 404)
            # Swagger does not display the response body if error. Setting status to ok for illustration purposes
            res$status <- 404
            msg <- paste0(sprintf("There is no ad with id %s in the database", ad_id))
            res$setHeader("Content-Type", "application/json")
            res$body <- list(error = msg)
            return(res$body)
        }
    }
    plumber::forward()
}

# > Static file handlers ----

#* Static file handler.
#* @assets /usr/local/lib/R/site-library/adspool/img /ads/files
list()

# The static file handler exposes files within the folder, but does not expose the folder for browsing
# To test the static file handler, navigate to <api_base_url:port>/ads/files/<filename>
#   Example: https://renkulab.io/jupyterhub/user/gustavo.martinez/mirailabs-2-0-43b938b9/rstudio/p/85c4e429/ads/files/001_MarioKart.jpeg
#   Example: http://127.0.0.1:8000/ads/files/001_MarioKart.jpeg